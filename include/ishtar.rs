/* automatically generated by rust-bindgen 0.69.4 */

pub const ISHTAR_VERSION: &[u8; 27] = b"0.30.1.2558-master+54046a5\0";
pub const ISHTAR_VERSION_MAJOR: u32 = 0;
pub const ISHTAR_VERSION_MINOR: u32 = 30;
pub const ISHTAR_VERSION_PATH: u32 = 1;
pub const ISHTAR_VERSION_COMMIT_SHA: &[u8; 41] = b"54046a5883e57a19c4a052821705aef92b773f55\0";
pub const ISHTAR_VERSION_BRANCH: &[u8; 7] = b"master\0";
pub const ISHTAR_VERSION_COMMIT_DATE: &[u8; 11] = b"2024-07-27\0";
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decimal_t {
    pub h: u64,
    pub l: u64,
}
#[test]
fn bindgen_test_layout_decimal_t() {
    const UNINIT: ::std::mem::MaybeUninit<decimal_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<decimal_t>(),
        16usize,
        concat!("Size of: ", stringify!(decimal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<decimal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(decimal_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decimal_t),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(decimal_t),
            "::",
            stringify!(l)
        )
    );
}
pub type half_t = u16;
pub const gc_flags_t_NONE: gc_flags_t = 0;
pub const gc_flags_t_NATIVE_REF: gc_flags_t = 2;
pub const gc_flags_t_IMMORTAL: gc_flags_t = 4;
pub type gc_flags_t = ::std::os::raw::c_int;
pub const gc_color_t_RED: gc_color_t = 0;
pub const gc_color_t_YELLOW: gc_color_t = 1;
pub const gc_color_t_GREEN: gc_color_t = 2;
pub type gc_color_t = ::std::os::raw::c_int;
pub const ishtar_error_e_ISHTAR_ERR_NONE: ishtar_error_e = 0;
pub const ishtar_error_e_ISHTAR_ERR_MISSING_METHOD: ishtar_error_e = 1;
pub const ishtar_error_e_ISHTAR_ERR_MISSING_FIELD: ishtar_error_e = 2;
pub const ishtar_error_e_ISHTAR_ERR_MISSING_TYPE: ishtar_error_e = 3;
pub const ishtar_error_e_ISHTAR_ERR_TYPE_LOAD: ishtar_error_e = 4;
pub const ishtar_error_e_ISHTAR_ERR_TYPE_MISMATCH: ishtar_error_e = 5;
pub const ishtar_error_e_ISHTAR_ERR_MEMBER_ACCESS: ishtar_error_e = 6;
pub const ishtar_error_e_ISHTAR_ERR_STATE_CORRUPT: ishtar_error_e = 7;
pub const ishtar_error_e_ISHTAR_ERR_ASSEMBLY_COULD_NOT_LOAD: ishtar_error_e = 8;
pub const ishtar_error_e_ISHTAR_ERR_END_EXECUTE_MEMORY: ishtar_error_e = 9;
pub const ishtar_error_e_ISHTAR_ERR_OUT_OF_MEMORY: ishtar_error_e = 10;
pub const ishtar_error_e_ISHTAR_ERR_ACCESS_VIOLATION: ishtar_error_e = 11;
pub const ishtar_error_e_ISHTAR_ERR_OVERFLOW: ishtar_error_e = 12;
pub const ishtar_error_e_ISHTAR_ERR_OUT_OF_RANGE: ishtar_error_e = 13;
pub const ishtar_error_e_ISHTAR_ERR_NATIVE_LIBRARY_COULD_NOT_LOAD: ishtar_error_e = 14;
pub const ishtar_error_e_ISHTAR_ERR_NATIVE_LIBRARY_SYMBOL_COULD_NOT_FOUND: ishtar_error_e = 15;
pub const ishtar_error_e_ISHTAR_ERR_MEMORY_LEAK: ishtar_error_e = 16;
pub const ishtar_error_e_ISHTAR_ERR_JIT_ASM_GENERATOR_TYPE_FAULT: ishtar_error_e = 17;
pub const ishtar_error_e_ISHTAR_ERR_JIT_ASM_GENERATOR_INCORRECT_CAST: ishtar_error_e = 18;
pub const ishtar_error_e_ISHTAR_ERR_GC_MOVED_UNMOVABLE_MEMORY: ishtar_error_e = 19;
pub const ishtar_error_e_ISHTAR_ERR_PROTECTED_ZONE_LABEL_CORRUPT: ishtar_error_e = 20;
pub const ishtar_error_e_ISHTAR_ERR_SEMAPHORE_FAILED: ishtar_error_e = 21;
pub const ishtar_error_e_ISHTAR_ERR_THREAD_STATE_CORRUPTED: ishtar_error_e = 22;
pub type ishtar_error_e = ::std::os::raw::c_int;
pub const ishtar_thread_status_e_THREAD_STATUS_CREATED: ishtar_thread_status_e = 0;
pub const ishtar_thread_status_e_THREAD_STATUS_RUNNING: ishtar_thread_status_e = 1;
pub const ishtar_thread_status_e_THREAD_STATUS_PAUSED: ishtar_thread_status_e = 2;
pub const ishtar_thread_status_e_THREAD_STATUS_EXITED: ishtar_thread_status_e = 3;
pub type ishtar_thread_status_e = ::std::os::raw::c_int;
pub const ishtar_job_status_e_JOB_STATUS_CREATED: ishtar_job_status_e = 0;
pub const ishtar_job_status_e_JOB_STATUS_RUNNING: ishtar_job_status_e = 1;
pub const ishtar_job_status_e_JOB_STATUS_PAUSED: ishtar_job_status_e = 2;
pub const ishtar_job_status_e_JOB_STATUS_CANCELED: ishtar_job_status_e = 3;
pub const ishtar_job_status_e_JOB_STATUS_EXITED: ishtar_job_status_e = 4;
pub type ishtar_job_status_e = ::std::os::raw::c_int;
pub const x64_instruction_target_t_PUSH: x64_instruction_target_t = 0;
pub const x64_instruction_target_t_MOV: x64_instruction_target_t = 1;
pub type x64_instruction_target_t = ::std::os::raw::c_int;
pub const class_flag_t_CLASS_NONE: class_flag_t = 0;
pub const class_flag_t_CLASS_PUBLIC: class_flag_t = 2;
pub const class_flag_t_CLASS_STATIC: class_flag_t = 4;
pub const class_flag_t_CLASS_INTERNAL: class_flag_t = 8;
pub const class_flag_t_CLASS_PROTECTED: class_flag_t = 16;
pub const class_flag_t_CLASS_PRIVATE: class_flag_t = 32;
pub const class_flag_t_CLASS_ABSTRACT: class_flag_t = 64;
pub const class_flag_t_CLASS_SPECIAL: class_flag_t = 128;
pub const class_flag_t_CLASS_INTERFACE: class_flag_t = 256;
pub const class_flag_t_CLASS_ASPECT: class_flag_t = 512;
pub const class_flag_t_CLASS_UNDEFINED: class_flag_t = 1024;
pub const class_flag_t_CLASS_UNRESOLVED: class_flag_t = 2048;
pub const class_flag_t_CLASS_PREDEFINED: class_flag_t = 4096;
pub const class_flag_t_CLASS_NOTCOMPLETED: class_flag_t = 8192;
pub const class_flag_t_CLASS_AMORPHOUS: class_flag_t = 16384;
pub type class_flag_t = ::std::os::raw::c_int;
pub const field_flag_t_FIELD_NONE: field_flag_t = 0;
pub const field_flag_t_FIELD_LITERAL: field_flag_t = 2;
pub const field_flag_t_FIELD_PUBLIC: field_flag_t = 4;
pub const field_flag_t_FIELD_STATIC: field_flag_t = 8;
pub const field_flag_t_FIELD_PROTECTED: field_flag_t = 16;
pub const field_flag_t_FIELD_VIRTUAL: field_flag_t = 32;
pub const field_flag_t_FIELD_ABSTRACT: field_flag_t = 64;
pub const field_flag_t_FIELD_OVERRIDE: field_flag_t = 128;
pub const field_flag_t_FIELD_SPECIAL: field_flag_t = 256;
pub const field_flag_t_FIELD_READONLY: field_flag_t = 512;
pub const field_flag_t_FIELD_INTERNAL: field_flag_t = 1024;
pub type field_flag_t = ::std::os::raw::c_int;
pub const method_flags_t_METHOD_NONE: method_flags_t = 0;
pub const method_flags_t_METHOD_PUBLIC: method_flags_t = 1;
pub const method_flags_t_METHOD_STATIC: method_flags_t = 2;
pub const method_flags_t_METHOD_INTERNAL: method_flags_t = 4;
pub const method_flags_t_METHOD_PROTECTED: method_flags_t = 8;
pub const method_flags_t_METHOD_PRIVATE: method_flags_t = 16;
pub const method_flags_t_METHOD_EXTERN: method_flags_t = 32;
pub const method_flags_t_METHOD_VIRTUAL: method_flags_t = 64;
pub const method_flags_t_METHOD_ABSTRACT: method_flags_t = 128;
pub const method_flags_t_METHOD_OVERRIDE: method_flags_t = 256;
pub const method_flags_t_METHOD_SPECIAL: method_flags_t = 512;
pub const method_flags_t_METHOD_ASYNC: method_flags_t = 1024;
pub const method_flags_t_METHOD_GENERIC: method_flags_t = 2048;
pub type method_flags_t = ::std::os::raw::c_int;
pub const ishtar_opcode_e_OPCODE_NOP: ishtar_opcode_e = 0;
pub const ishtar_opcode_e_OPCODE_ADD: ishtar_opcode_e = 1;
pub const ishtar_opcode_e_OPCODE_SUB: ishtar_opcode_e = 2;
pub const ishtar_opcode_e_OPCODE_DIV: ishtar_opcode_e = 3;
pub const ishtar_opcode_e_OPCODE_MUL: ishtar_opcode_e = 4;
pub const ishtar_opcode_e_OPCODE_MOD: ishtar_opcode_e = 5;
pub const ishtar_opcode_e_OPCODE_LDARG_0: ishtar_opcode_e = 6;
pub const ishtar_opcode_e_OPCODE_LDARG_1: ishtar_opcode_e = 7;
pub const ishtar_opcode_e_OPCODE_LDARG_2: ishtar_opcode_e = 8;
pub const ishtar_opcode_e_OPCODE_LDARG_3: ishtar_opcode_e = 9;
pub const ishtar_opcode_e_OPCODE_LDARG_4: ishtar_opcode_e = 10;
pub const ishtar_opcode_e_OPCODE_LDARG_5: ishtar_opcode_e = 11;
pub const ishtar_opcode_e_OPCODE_LDARG_S: ishtar_opcode_e = 12;
pub const ishtar_opcode_e_OPCODE_STARG_0: ishtar_opcode_e = 13;
pub const ishtar_opcode_e_OPCODE_STARG_1: ishtar_opcode_e = 14;
pub const ishtar_opcode_e_OPCODE_STARG_2: ishtar_opcode_e = 15;
pub const ishtar_opcode_e_OPCODE_STARG_3: ishtar_opcode_e = 16;
pub const ishtar_opcode_e_OPCODE_STARG_4: ishtar_opcode_e = 17;
pub const ishtar_opcode_e_OPCODE_STARG_5: ishtar_opcode_e = 18;
pub const ishtar_opcode_e_OPCODE_STARG_S: ishtar_opcode_e = 19;
pub const ishtar_opcode_e_OPCODE_LDC_F4: ishtar_opcode_e = 20;
pub const ishtar_opcode_e_OPCODE_LDC_F2: ishtar_opcode_e = 21;
pub const ishtar_opcode_e_OPCODE_LDC_STR: ishtar_opcode_e = 22;
pub const ishtar_opcode_e_OPCODE_LDC_I4_0: ishtar_opcode_e = 23;
pub const ishtar_opcode_e_OPCODE_LDC_I4_1: ishtar_opcode_e = 24;
pub const ishtar_opcode_e_OPCODE_LDC_I4_2: ishtar_opcode_e = 25;
pub const ishtar_opcode_e_OPCODE_LDC_I4_3: ishtar_opcode_e = 26;
pub const ishtar_opcode_e_OPCODE_LDC_I4_4: ishtar_opcode_e = 27;
pub const ishtar_opcode_e_OPCODE_LDC_I4_5: ishtar_opcode_e = 28;
pub const ishtar_opcode_e_OPCODE_LDC_I4_S: ishtar_opcode_e = 29;
pub const ishtar_opcode_e_OPCODE_LDC_I2_0: ishtar_opcode_e = 30;
pub const ishtar_opcode_e_OPCODE_LDC_I2_1: ishtar_opcode_e = 31;
pub const ishtar_opcode_e_OPCODE_LDC_I2_2: ishtar_opcode_e = 32;
pub const ishtar_opcode_e_OPCODE_LDC_I2_3: ishtar_opcode_e = 33;
pub const ishtar_opcode_e_OPCODE_LDC_I2_4: ishtar_opcode_e = 34;
pub const ishtar_opcode_e_OPCODE_LDC_I2_5: ishtar_opcode_e = 35;
pub const ishtar_opcode_e_OPCODE_LDC_I2_S: ishtar_opcode_e = 36;
pub const ishtar_opcode_e_OPCODE_LDC_I8_0: ishtar_opcode_e = 37;
pub const ishtar_opcode_e_OPCODE_LDC_I8_1: ishtar_opcode_e = 38;
pub const ishtar_opcode_e_OPCODE_LDC_I8_2: ishtar_opcode_e = 39;
pub const ishtar_opcode_e_OPCODE_LDC_I8_3: ishtar_opcode_e = 40;
pub const ishtar_opcode_e_OPCODE_LDC_I8_4: ishtar_opcode_e = 41;
pub const ishtar_opcode_e_OPCODE_LDC_I8_5: ishtar_opcode_e = 42;
pub const ishtar_opcode_e_OPCODE_LDC_I8_S: ishtar_opcode_e = 43;
pub const ishtar_opcode_e_OPCODE_LDC_F8: ishtar_opcode_e = 44;
pub const ishtar_opcode_e_OPCODE_LDC_F16: ishtar_opcode_e = 45;
pub const ishtar_opcode_e_OPCODE_RESERVED_0: ishtar_opcode_e = 46;
pub const ishtar_opcode_e_OPCODE_RESERVED_1: ishtar_opcode_e = 47;
pub const ishtar_opcode_e_OPCODE_RESERVED_2: ishtar_opcode_e = 48;
pub const ishtar_opcode_e_OPCODE_RET: ishtar_opcode_e = 49;
pub const ishtar_opcode_e_OPCODE_CALL: ishtar_opcode_e = 50;
pub const ishtar_opcode_e_OPCODE_LDNULL: ishtar_opcode_e = 51;
pub const ishtar_opcode_e_OPCODE_LDF: ishtar_opcode_e = 52;
pub const ishtar_opcode_e_OPCODE_LDSF: ishtar_opcode_e = 53;
pub const ishtar_opcode_e_OPCODE_STF: ishtar_opcode_e = 54;
pub const ishtar_opcode_e_OPCODE_STSF: ishtar_opcode_e = 55;
pub const ishtar_opcode_e_OPCODE_LDLOC_0: ishtar_opcode_e = 56;
pub const ishtar_opcode_e_OPCODE_LDLOC_1: ishtar_opcode_e = 57;
pub const ishtar_opcode_e_OPCODE_LDLOC_2: ishtar_opcode_e = 58;
pub const ishtar_opcode_e_OPCODE_LDLOC_3: ishtar_opcode_e = 59;
pub const ishtar_opcode_e_OPCODE_LDLOC_4: ishtar_opcode_e = 60;
pub const ishtar_opcode_e_OPCODE_LDLOC_5: ishtar_opcode_e = 61;
pub const ishtar_opcode_e_OPCODE_LDLOC_S: ishtar_opcode_e = 62;
pub const ishtar_opcode_e_OPCODE_STLOC_0: ishtar_opcode_e = 63;
pub const ishtar_opcode_e_OPCODE_STLOC_1: ishtar_opcode_e = 64;
pub const ishtar_opcode_e_OPCODE_STLOC_2: ishtar_opcode_e = 65;
pub const ishtar_opcode_e_OPCODE_STLOC_3: ishtar_opcode_e = 66;
pub const ishtar_opcode_e_OPCODE_STLOC_4: ishtar_opcode_e = 67;
pub const ishtar_opcode_e_OPCODE_STLOC_5: ishtar_opcode_e = 68;
pub const ishtar_opcode_e_OPCODE_STLOC_S: ishtar_opcode_e = 69;
pub const ishtar_opcode_e_OPCODE_LOC_INIT: ishtar_opcode_e = 70;
pub const ishtar_opcode_e_OPCODE_LOC_INIT_X: ishtar_opcode_e = 71;
pub const ishtar_opcode_e_OPCODE_DUP: ishtar_opcode_e = 72;
pub const ishtar_opcode_e_OPCODE_XOR: ishtar_opcode_e = 73;
pub const ishtar_opcode_e_OPCODE_OR: ishtar_opcode_e = 74;
pub const ishtar_opcode_e_OPCODE_AND: ishtar_opcode_e = 75;
pub const ishtar_opcode_e_OPCODE_SHR: ishtar_opcode_e = 76;
pub const ishtar_opcode_e_OPCODE_SHL: ishtar_opcode_e = 77;
pub const ishtar_opcode_e_OPCODE_CONV_R4: ishtar_opcode_e = 78;
pub const ishtar_opcode_e_OPCODE_CONV_R8: ishtar_opcode_e = 79;
pub const ishtar_opcode_e_OPCODE_CONV_I4: ishtar_opcode_e = 80;
pub const ishtar_opcode_e_OPCODE_THROW: ishtar_opcode_e = 81;
pub const ishtar_opcode_e_OPCODE_NEWOBJ: ishtar_opcode_e = 82;
pub const ishtar_opcode_e_OPCODE_NEWARR: ishtar_opcode_e = 83;
pub const ishtar_opcode_e_OPCODE_LDLEN: ishtar_opcode_e = 84;
pub const ishtar_opcode_e_OPCODE_LDELEM_S: ishtar_opcode_e = 85;
pub const ishtar_opcode_e_OPCODE_STELEM_S: ishtar_opcode_e = 86;
pub const ishtar_opcode_e_OPCODE_LD_TYPE: ishtar_opcode_e = 87;
pub const ishtar_opcode_e_OPCODE_EQL_LQ: ishtar_opcode_e = 88;
pub const ishtar_opcode_e_OPCODE_EQL_L: ishtar_opcode_e = 89;
pub const ishtar_opcode_e_OPCODE_EQL_HQ: ishtar_opcode_e = 90;
pub const ishtar_opcode_e_OPCODE_EQL_H: ishtar_opcode_e = 91;
pub const ishtar_opcode_e_OPCODE_EQL_NQ: ishtar_opcode_e = 92;
pub const ishtar_opcode_e_OPCODE_EQL_NN: ishtar_opcode_e = 93;
pub const ishtar_opcode_e_OPCODE_EQL_F: ishtar_opcode_e = 94;
pub const ishtar_opcode_e_OPCODE_EQL_T: ishtar_opcode_e = 95;
pub const ishtar_opcode_e_OPCODE_JMP: ishtar_opcode_e = 96;
pub const ishtar_opcode_e_OPCODE_JMP_LQ: ishtar_opcode_e = 97;
pub const ishtar_opcode_e_OPCODE_JMP_L: ishtar_opcode_e = 98;
pub const ishtar_opcode_e_OPCODE_JMP_HQ: ishtar_opcode_e = 99;
pub const ishtar_opcode_e_OPCODE_JMP_H: ishtar_opcode_e = 100;
pub const ishtar_opcode_e_OPCODE_JMP_NQ: ishtar_opcode_e = 101;
pub const ishtar_opcode_e_OPCODE_JMP_NN: ishtar_opcode_e = 102;
pub const ishtar_opcode_e_OPCODE_JMP_F: ishtar_opcode_e = 103;
pub const ishtar_opcode_e_OPCODE_JMP_T: ishtar_opcode_e = 104;
pub const ishtar_opcode_e_OPCODE_POP: ishtar_opcode_e = 105;
pub const ishtar_opcode_e_OPCODE_ALLOC_BLOCK: ishtar_opcode_e = 106;
pub const ishtar_opcode_e_OPCODE_DELETE: ishtar_opcode_e = 107;
pub const ishtar_opcode_e_OPCODE_SEH_LEAVE_S: ishtar_opcode_e = 108;
pub const ishtar_opcode_e_OPCODE_SEH_LEAVE: ishtar_opcode_e = 109;
pub const ishtar_opcode_e_OPCODE_SEH_FINALLY: ishtar_opcode_e = 110;
pub const ishtar_opcode_e_OPCODE_SEH_FILTER: ishtar_opcode_e = 111;
pub const ishtar_opcode_e_OPCODE_SEH_ENTER: ishtar_opcode_e = 112;
pub const ishtar_opcode_e_OPCODE_CAST: ishtar_opcode_e = 113;
pub const ishtar_opcode_e_OPCODE_CALL_SP: ishtar_opcode_e = 114;
pub const ishtar_opcode_e_OPCODE_LDFN: ishtar_opcode_e = 115;
pub const ishtar_opcode_e_OPCODE_LD_TYPE_G: ishtar_opcode_e = 116;
pub type ishtar_opcode_e = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_version_t {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
    pub build: u32,
}
#[test]
fn bindgen_test_layout_ishtar_version_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_version_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_version_t>(),
        16usize,
        concat!("Size of: ", stringify!(ishtar_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_version_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ishtar_version_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_version_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_version_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_version_t),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_version_t),
            "::",
            stringify!(build)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_array_block_t {
    pub offset_value: u64,
    pub offset_block: u64,
    pub offset_rank: u64,
    pub offset_size: u64,
}
#[test]
fn bindgen_test_layout_ishtar_array_block_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_array_block_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_array_block_t>(),
        32usize,
        concat!("Size of: ", stringify!(ishtar_array_block_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_array_block_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_array_block_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_block_t),
            "::",
            stringify!(offset_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_block) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_block_t),
            "::",
            stringify!(offset_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_rank) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_block_t),
            "::",
            stringify!(offset_rank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_block_t),
            "::",
            stringify!(offset_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_array_t {
    pub clazz: *mut ishtar_class_t,
    pub memory: *mut ishtar_object_t,
    pub flags: gc_flags_t,
    pub vtable_size: u32,
    pub owner: *mut ::std::os::raw::c_void,
    pub __gc_id: i64,
    pub element_clazz: *mut ishtar_class_t,
    pub _block: ishtar_array_block_t,
}
#[test]
fn bindgen_test_layout_ishtar_array_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_array_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_array_t>(),
        80usize,
        concat!("Size of: ", stringify!(ishtar_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_array_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clazz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(clazz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(vtable_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__gc_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(__gc_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_clazz) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(element_clazz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._block) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_array_t),
            "::",
            stringify!(_block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_frames_t {
    pub module_loader_frame: *mut call_frame_t,
    pub entry_point: *mut call_frame_t,
    pub jit: *mut call_frame_t,
    pub garbage_collector: *mut call_frame_t,
    pub native_loader: *mut call_frame_t,
}
#[test]
fn bindgen_test_layout_ishtar_frames_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_frames_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_frames_t>(),
        40usize,
        concat!("Size of: ", stringify!(ishtar_frames_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_frames_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_frames_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_loader_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_frames_t),
            "::",
            stringify!(module_loader_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_point) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_frames_t),
            "::",
            stringify!(entry_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_frames_t),
            "::",
            stringify!(jit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).garbage_collector) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_frames_t),
            "::",
            stringify!(garbage_collector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_loader) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_frames_t),
            "::",
            stringify!(native_loader)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_object_t {
    pub clazz: *mut ishtar_class_t,
    pub vtable: *mut ::std::os::raw::c_void,
    pub flags: gc_flags_t,
    pub color: gc_color_t,
    pub refs_size: u64,
    pub vtable_size: u32,
    pub __gc_id: i64,
    pub m1: i64,
    pub m2: i64,
}
#[test]
fn bindgen_test_layout_ishtar_object_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_object_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_object_t>(),
        64usize,
        concat!("Size of: ", stringify!(ishtar_object_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_object_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_object_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clazz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(clazz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(refs_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(vtable_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__gc_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(__gc_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(m1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_object_t),
            "::",
            stringify!(m2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_ncd_t {
    pub procedure: usize,
    pub arg_count: i64,
    pub return_memory_pointer: usize,
    pub args_pointer: usize,
}
#[test]
fn bindgen_test_layout_ishtar_ncd_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_ncd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_ncd_t>(),
        32usize,
        concat!("Size of: ", stringify!(ishtar_ncd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_ncd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_ncd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).procedure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_ncd_t),
            "::",
            stringify!(procedure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_ncd_t),
            "::",
            stringify!(arg_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_memory_pointer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_ncd_t),
            "::",
            stringify!(return_memory_pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args_pointer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_ncd_t),
            "::",
            stringify!(args_pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x64_asm_step_t {
    pub instruction: x64_instruction_target_t,
    pub _register: i32,
    pub stack_offset: i32,
}
#[test]
fn bindgen_test_layout_x64_asm_step_t() {
    const UNINIT: ::std::mem::MaybeUninit<x64_asm_step_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x64_asm_step_t>(),
        12usize,
        concat!("Size of: ", stringify!(x64_asm_step_t))
    );
    assert_eq!(
        ::std::mem::align_of::<x64_asm_step_t>(),
        4usize,
        concat!("Alignment of ", stringify!(x64_asm_step_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instruction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x64_asm_step_t),
            "::",
            stringify!(instruction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._register) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x64_asm_step_t),
            "::",
            stringify!(_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x64_asm_step_t),
            "::",
            stringify!(stack_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_rtoken_t {
    pub value: u64,
    pub module_i_d: u32,
    pub class_i_d: u32,
}
#[test]
fn bindgen_test_layout_ishtar_rtoken_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_rtoken_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_rtoken_t>(),
        16usize,
        concat!("Size of: ", stringify!(ishtar_rtoken_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_rtoken_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_rtoken_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_rtoken_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_i_d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_rtoken_t),
            "::",
            stringify!(module_i_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_i_d) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_rtoken_t),
            "::",
            stringify!(class_i_d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_string_t {
    pub id: u64,
    pub i_d: u64,
}
#[test]
fn bindgen_test_layout_ishtar_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(ishtar_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_string_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_string_t),
            "::",
            stringify!(i_d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_method_call_info_t {
    pub module_handle: usize,
    pub symbol_handle: usize,
    pub extern_function_declaration: *mut ::std::os::raw::c_void,
    pub jitted_wrapper: *mut ::std::os::raw::c_void,
    pub compiled_func_ref: usize,
    pub is_internal: bool,
}
#[test]
fn bindgen_test_layout_ishtar_method_call_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_method_call_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_method_call_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(ishtar_method_call_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_method_call_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_method_call_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_call_info_t),
            "::",
            stringify!(module_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_call_info_t),
            "::",
            stringify!(symbol_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extern_function_declaration) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_call_info_t),
            "::",
            stringify!(extern_function_declaration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitted_wrapper) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_call_info_t),
            "::",
            stringify!(jitted_wrapper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compiled_func_ref) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_call_info_t),
            "::",
            stringify!(compiled_func_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_internal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_call_info_t),
            "::",
            stringify!(is_internal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_method_t {
    pub _self: *mut ::std::os::raw::c_void,
    pub header: *mut ishtar_method_header_t,
    pub p_i_info: ishtar_method_call_info_t,
    pub vtable_offset: u64,
    pub _name: *mut ishtar_string_t,
    pub _raw_name: *mut ishtar_string_t,
    pub _ctor_called: bool,
    pub flags: method_flags_t,
    pub owner: *mut ishtar_class_t,
    pub aspects: *mut ::std::os::raw::c_void,
    pub signature: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_method_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_method_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_method_t>(),
        120usize,
        concat!("Size of: ", stringify!(ishtar_method_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_method_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_method_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._self) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_i_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(p_i_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable_offset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._raw_name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(_raw_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ctor_called) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(_ctor_called)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspects) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(aspects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_t),
            "::",
            stringify!(signature)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_callframe_exception_t {
    pub last_ip: *mut ::std::os::raw::c_void,
    pub value: *mut ishtar_object_t,
    pub stack_trace: *mut ishtar_string_t,
}
#[test]
fn bindgen_test_layout_ishtar_callframe_exception_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_callframe_exception_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_callframe_exception_t>(),
        24usize,
        concat!("Size of: ", stringify!(ishtar_callframe_exception_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_callframe_exception_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_callframe_exception_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_callframe_exception_t),
            "::",
            stringify!(last_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_callframe_exception_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_trace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_callframe_exception_t),
            "::",
            stringify!(stack_trace)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct call_frame_t {
    pub self_: *mut call_frame_t,
    pub parent: *mut call_frame_t,
    pub method: *mut ishtar_method_t,
    pub level: i32,
    pub return_value: *mut ::std::os::raw::c_void,
    pub args: *mut ::std::os::raw::c_void,
    pub last_ip: ishtar_opcode_e,
    pub exception: ishtar_callframe_exception_t,
}
#[test]
fn bindgen_test_layout_call_frame_t() {
    const UNINIT: ::std::mem::MaybeUninit<call_frame_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<call_frame_t>(),
        80usize,
        concat!("Size of: ", stringify!(call_frame_t))
    );
    assert_eq!(
        ::std::mem::align_of::<call_frame_t>(),
        8usize,
        concat!("Alignment of ", stringify!(call_frame_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(return_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_ip) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(last_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(call_frame_t),
            "::",
            stringify!(exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_illabel_t {
    pub pos: i32,
    pub opcode: ishtar_opcode_e,
}
#[test]
fn bindgen_test_layout_ishtar_illabel_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_illabel_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_illabel_t>(),
        8usize,
        concat!("Size of: ", stringify!(ishtar_illabel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_illabel_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ishtar_illabel_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_illabel_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_illabel_t),
            "::",
            stringify!(opcode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_types_t {
    pub object_class: *mut ishtar_class_t,
    pub value_type_class: *mut ishtar_class_t,
    pub void_class: *mut ishtar_class_t,
    pub string_class: *mut ishtar_class_t,
    pub byte_class: *mut ishtar_class_t,
    pub s_byte_class: *mut ishtar_class_t,
    pub int32_class: *mut ishtar_class_t,
    pub int16_class: *mut ishtar_class_t,
    pub int64_class: *mut ishtar_class_t,
    pub u_int32_class: *mut ishtar_class_t,
    pub u_int16_class: *mut ishtar_class_t,
    pub u_int64_class: *mut ishtar_class_t,
    pub half_class: *mut ishtar_class_t,
    pub float_class: *mut ishtar_class_t,
    pub double_class: *mut ishtar_class_t,
    pub decimal_class: *mut ishtar_class_t,
    pub bool_class: *mut ishtar_class_t,
    pub char_class: *mut ishtar_class_t,
    pub array_class: *mut ishtar_class_t,
    pub exception_class: *mut ishtar_class_t,
    pub raw_class: *mut ishtar_class_t,
    pub aspect_class: *mut ishtar_class_t,
    pub function_class: *mut ishtar_class_t,
    pub range_class: *mut ishtar_class_t,
    pub all: *mut ::std::os::raw::c_void,
    pub mapping: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_types_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_types_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_types_t>(),
        208usize,
        concat!("Size of: ", stringify!(ishtar_types_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_types_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_types_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(object_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type_class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(value_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).void_class) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(void_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_class) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(string_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_class) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(byte_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_byte_class) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(s_byte_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int32_class) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(int32_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int16_class) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(int16_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int64_class) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(int64_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u_int32_class) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(u_int32_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u_int16_class) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(u_int16_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u_int64_class) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(u_int64_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).half_class) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(half_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).float_class) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(float_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).double_class) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(double_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimal_class) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(decimal_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bool_class) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(bool_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).char_class) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(char_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_class) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(array_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_class) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(exception_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_class) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(raw_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect_class) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(aspect_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function_class) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(function_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_class) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(range_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(all)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapping) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_types_t),
            "::",
            stringify!(mapping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_method_header_t {
    pub code_size: u32,
    pub code: *mut ::std::os::raw::c_void,
    pub max_stack: i16,
    pub exception_handler_list: *mut ::std::os::raw::c_void,
    pub labels_map: *mut ::std::os::raw::c_void,
    pub labels: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_method_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_method_header_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_method_header_t>(),
        48usize,
        concat!("Size of: ", stringify!(ishtar_method_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_method_header_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_method_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_header_t),
            "::",
            stringify!(code_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_header_t),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_stack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_header_t),
            "::",
            stringify!(max_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_handler_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_header_t),
            "::",
            stringify!(exception_handler_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).labels_map) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_header_t),
            "::",
            stringify!(labels_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).labels) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_method_header_t),
            "::",
            stringify!(labels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeIshtarAlias_Method {
    pub name: *mut ::std::os::raw::c_void,
    pub method: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RuntimeIshtarAlias_Method() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeIshtarAlias_Method> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarAlias_Method>(),
        16usize,
        concat!("Size of: ", stringify!(RuntimeIshtarAlias_Method))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarAlias_Method>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeIshtarAlias_Method))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarAlias_Method),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarAlias_Method),
            "::",
            stringify!(method)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeIshtarAlias_Type {
    pub name: *mut ::std::os::raw::c_void,
    pub _class: *mut ishtar_class_t,
}
#[test]
fn bindgen_test_layout_RuntimeIshtarAlias_Type() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeIshtarAlias_Type> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarAlias_Type>(),
        16usize,
        concat!("Size of: ", stringify!(RuntimeIshtarAlias_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarAlias_Type>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeIshtarAlias_Type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarAlias_Type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarAlias_Type),
            "::",
            stringify!(_class)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RuntimeIshtarAlias {
    pub __bindgen_anon_1: RuntimeIshtarAlias__bindgen_ty_1,
    pub __bindgen_anon_2: RuntimeIshtarAlias__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RuntimeIshtarAlias__bindgen_ty_1 {
    pub kind: u8,
}
#[test]
fn bindgen_test_layout_RuntimeIshtarAlias__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeIshtarAlias__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarAlias__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RuntimeIshtarAlias__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarAlias__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RuntimeIshtarAlias__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarAlias__bindgen_ty_1),
            "::",
            stringify!(kind)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RuntimeIshtarAlias__bindgen_ty_2 {
    pub method: RuntimeIshtarAlias_Method,
    pub type_: RuntimeIshtarAlias_Type,
}
#[test]
fn bindgen_test_layout_RuntimeIshtarAlias__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeIshtarAlias__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarAlias__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(RuntimeIshtarAlias__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarAlias__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RuntimeIshtarAlias__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarAlias__bindgen_ty_2),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarAlias__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
}
#[test]
fn bindgen_test_layout_RuntimeIshtarAlias() {
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarAlias>(),
        24usize,
        concat!("Size of: ", stringify!(RuntimeIshtarAlias))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarAlias>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeIshtarAlias))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_class_t {
    pub _self_reference: *mut ::std::os::raw::c_void,
    pub methods: *mut ::std::os::raw::c_void,
    pub fields: *mut ::std::os::raw::c_void,
    pub aspects: *mut ::std::os::raw::c_void,
    pub owner: *mut ishtar_module_t,
    pub parent: *mut ishtar_class_t,
    pub full_name: *mut ::std::os::raw::c_void,
    pub _is_disposed: bool,
    pub type_code: i32,
    pub flags: class_flag_t,
    pub runtime_token: ishtar_rtoken_t,
    pub i_d: u32,
    pub magic1: u16,
    pub magic2: u16,
    pub computed_size: u64,
    pub is_inited: bool,
    pub vtable: *mut ::std::os::raw::c_void,
    pub vtable_size: u64,
}
#[test]
fn bindgen_test_layout_ishtar_class_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_class_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_class_t>(),
        128usize,
        concat!("Size of: ", stringify!(ishtar_class_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_class_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_class_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._self_reference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(_self_reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspects) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(aspects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(full_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._is_disposed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(_is_disposed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_code) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(type_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).runtime_token) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(runtime_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_d) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(i_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic1) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic2) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(magic2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computed_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(computed_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_inited) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(is_inited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable_size) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_class_t),
            "::",
            stringify!(vtable_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeComplexType {
    pub _type_arg: *mut ::std::os::raw::c_void,
    pub _class: *mut ishtar_class_t,
}
#[test]
fn bindgen_test_layout_RuntimeComplexType() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeComplexType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeComplexType>(),
        16usize,
        concat!("Size of: ", stringify!(RuntimeComplexType))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeComplexType>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeComplexType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._type_arg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeComplexType),
            "::",
            stringify!(_type_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeComplexType),
            "::",
            stringify!(_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeIshtarField {
    pub owner: *mut ishtar_class_t,
    pub field_type: RuntimeComplexType,
    pub vtable_offset: u64,
    pub flags: field_flag_t,
    pub full_name: *mut ::std::os::raw::c_void,
    pub aspects: *mut ::std::os::raw::c_void,
    pub default_value: *mut ishtar_object_t,
    pub _self_ref: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RuntimeIshtarField() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeIshtarField> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarField>(),
        72usize,
        concat!("Size of: ", stringify!(RuntimeIshtarField))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarField>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeIshtarField))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(field_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(full_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspects) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(aspects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._self_ref) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarField),
            "::",
            stringify!(_self_ref)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeMethodArgument {
    pub type_: RuntimeComplexType,
    pub name: *mut ishtar_string_t,
    pub self_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RuntimeMethodArgument() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeMethodArgument> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeMethodArgument>(),
        32usize,
        concat!("Size of: ", stringify!(RuntimeMethodArgument))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeMethodArgument>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeMethodArgument))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeMethodArgument),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeMethodArgument),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeMethodArgument),
            "::",
            stringify!(self_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeIshtarTypeArg {
    pub id: *mut ishtar_string_t,
    pub name: *mut ishtar_string_t,
    pub constraints: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RuntimeIshtarTypeArg() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeIshtarTypeArg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarTypeArg>(),
        24usize,
        concat!("Size of: ", stringify!(RuntimeIshtarTypeArg))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarTypeArg>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeIshtarTypeArg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarTypeArg),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarTypeArg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constraints) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarTypeArg),
            "::",
            stringify!(constraints)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IshtarParameterConstraint {
    pub kind: i32,
    pub type_: *mut ishtar_class_t,
}
#[test]
fn bindgen_test_layout_IshtarParameterConstraint() {
    const UNINIT: ::std::mem::MaybeUninit<IshtarParameterConstraint> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IshtarParameterConstraint>(),
        16usize,
        concat!("Size of: ", stringify!(IshtarParameterConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<IshtarParameterConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(IshtarParameterConstraint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IshtarParameterConstraint),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IshtarParameterConstraint),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeIshtarSignature {
    pub return_type: RuntimeComplexType,
    pub arguments: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RuntimeIshtarSignature() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeIshtarSignature> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeIshtarSignature>(),
        24usize,
        concat!("Size of: ", stringify!(RuntimeIshtarSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeIshtarSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeIshtarSignature))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarSignature),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeIshtarSignature),
            "::",
            stringify!(arguments)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rawval_union {
    pub __bindgen_anon_1: rawval_union__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rawval_union__bindgen_ty_1 {
    pub m: *mut ishtar_method_t,
    pub c: *mut ishtar_class_t,
}
#[test]
fn bindgen_test_layout_rawval_union__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rawval_union__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rawval_union__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rawval_union__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rawval_union__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rawval_union__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rawval_union__bindgen_ty_1),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rawval_union__bindgen_ty_1),
            "::",
            stringify!(c)
        )
    );
}
#[test]
fn bindgen_test_layout_rawval_union() {
    assert_eq!(
        ::std::mem::size_of::<rawval_union>(),
        8usize,
        concat!("Size of: ", stringify!(rawval_union))
    );
    assert_eq!(
        ::std::mem::align_of::<rawval_union>(),
        8usize,
        concat!("Alignment of ", stringify!(rawval_union))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rawval {
    pub data: rawval_union,
    pub type_: i32,
}
#[test]
fn bindgen_test_layout_rawval() {
    const UNINIT: ::std::mem::MaybeUninit<rawval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rawval>(),
        16usize,
        concat!("Size of: ", stringify!(rawval))
    );
    assert_eq!(
        ::std::mem::align_of::<rawval>(),
        8usize,
        concat!("Alignment of ", stringify!(rawval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rawval),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rawval),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stack_union {
    pub __bindgen_anon_1: stack_union__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union stack_union__bindgen_ty_1 {
    pub b: i8,
    pub s: i16,
    pub i: i32,
    pub l: i64,
    pub ub: u8,
    pub us: u16,
    pub ui: u32,
    pub ul: u64,
    pub f_r4: f32,
    pub f: f64,
    pub d: decimal_t,
    pub hf: half_t,
    pub p: usize,
}
#[test]
fn bindgen_test_layout_stack_union__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<stack_union__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stack_union__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(stack_union__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_union__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_union__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ub) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ui) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(ui)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ul) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(ul)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_r4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(f_r4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(hf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_union__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_stack_union() {
    assert_eq!(
        ::std::mem::size_of::<stack_union>(),
        16usize,
        concat!("Size of: ", stringify!(stack_union))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_union>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_union))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stackval {
    pub data: stack_union,
    pub type_: i32,
}
#[test]
fn bindgen_test_layout_stackval() {
    const UNINIT: ::std::mem::MaybeUninit<stackval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stackval>(),
        24usize,
        concat!("Size of: ", stringify!(stackval))
    );
    assert_eq!(
        ::std::mem::align_of::<stackval>(),
        8usize,
        concat!("Alignment of ", stringify!(stackval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stackval),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stackval),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_trace_t {
    pub use_console: bool,
    pub use_file: bool,
}
#[test]
fn bindgen_test_layout_ishtar_trace_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_trace_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_trace_t>(),
        2usize,
        concat!("Size of: ", stringify!(ishtar_trace_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_trace_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ishtar_trace_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_console) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_trace_t),
            "::",
            stringify!(use_console)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_file) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_trace_t),
            "::",
            stringify!(use_file)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeInfo {
    pub is_windows: bool,
    pub is_linux: bool,
    pub is_o_s_x: bool,
    pub is_free_b_s_d: bool,
    pub architecture: i32,
}
#[test]
fn bindgen_test_layout_RuntimeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeInfo>(),
        8usize,
        concat!("Size of: ", stringify!(RuntimeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RuntimeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_windows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInfo),
            "::",
            stringify!(is_windows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_linux) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInfo),
            "::",
            stringify!(is_linux)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_o_s_x) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInfo),
            "::",
            stringify!(is_o_s_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_free_b_s_d) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInfo),
            "::",
            stringify!(is_free_b_s_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).architecture) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeInfo),
            "::",
            stringify!(architecture)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMContext {
    pub _ctx: *mut ::std::os::raw::c_void,
    pub _ffi_module: *mut ::std::os::raw::c_void,
    pub _execution_engine: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_LLVMContext() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMContext>(),
        24usize,
        concat!("Size of: ", stringify!(LLVMContext))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMContext>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMContext),
            "::",
            stringify!(_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ffi_module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMContext),
            "::",
            stringify!(_ffi_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._execution_engine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMContext),
            "::",
            stringify!(_execution_engine)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_threading_t {
    pub threads: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_threading_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_threading_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_threading_t>(),
        8usize,
        concat!("Size of: ", stringify!(ishtar_threading_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_threading_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_threading_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threads) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_threading_t),
            "::",
            stringify!(threads)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_t {
    pub name: *mut ishtar_string_t,
    pub frames: *mut ishtar_frames_t,
    pub trace: ishtar_trace_t,
    pub jitter: LLVMContext,
    pub types: *mut ishtar_types_t,
    pub threading: ishtar_threading_t,
    pub task_scheduler: *mut ishtar_scheduler_t,
    pub internal_module: *mut ishtar_module_t,
    pub internal_class: *mut ishtar_class_t,
}
#[test]
fn bindgen_test_layout_vm_t() {
    const UNINIT: ::std::mem::MaybeUninit<vm_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vm_t>(),
        88usize,
        concat!("Size of: ", stringify!(vm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threading) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(threading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task_scheduler) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(task_scheduler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_module) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(internal_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_class) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_t),
            "::",
            stringify!(internal_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_applet {
    pub _module: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vm_applet() {
    const UNINIT: ::std::mem::MaybeUninit<vm_applet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vm_applet>(),
        8usize,
        concat!("Size of: ", stringify!(vm_applet))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_applet>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_applet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_applet),
            "::",
            stringify!(_module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comparer_applet {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_comparer_applet() {
    assert_eq!(
        ::std::mem::size_of::<comparer_applet>(),
        4usize,
        concat!("Size of: ", stringify!(comparer_applet))
    );
    assert_eq!(
        ::std::mem::align_of::<comparer_applet>(),
        1usize,
        concat!("Alignment of ", stringify!(comparer_applet))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_thread_raw_t {
    pub main_module: *mut ishtar_module_t,
    pub thread_id: *mut ::std::os::raw::c_void,
    pub call_frame: *mut ::std::os::raw::c_void,
    pub name: *mut ishtar_string_t,
}
#[test]
fn bindgen_test_layout_ishtar_thread_raw_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_thread_raw_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_thread_raw_t>(),
        32usize,
        concat!("Size of: ", stringify!(ishtar_thread_raw_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_thread_raw_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_thread_raw_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).main_module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_raw_t),
            "::",
            stringify!(main_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_raw_t),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call_frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_raw_t),
            "::",
            stringify!(call_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_raw_t),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_task_t {
    pub index: u64,
    pub data: *mut ishtar_task_data_t,
    pub frame: *mut call_frame_t,
}
#[test]
fn bindgen_test_layout_ishtar_task_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_task_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_task_t>(),
        24usize,
        concat!("Size of: ", stringify!(ishtar_task_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_task_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_task_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_task_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_task_t),
            "::",
            stringify!(frame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_thread_t {
    pub ctx: *mut ishtar_thread_ctx_t,
    pub thread_id: *mut ::std::os::raw::c_void,
    pub call_frame: *mut call_frame_t,
}
#[test]
fn bindgen_test_layout_ishtar_thread_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_thread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_thread_t>(),
        24usize,
        concat!("Size of: ", stringify!(ishtar_thread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_thread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_thread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_t),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call_frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_t),
            "::",
            stringify!(call_frame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_thread_ctx_t {
    pub status: ishtar_thread_status_e,
    pub thread_id: *mut ::std::os::raw::c_void,
    pub locker: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_thread_ctx_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_thread_ctx_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_thread_ctx_t>(),
        24usize,
        concat!("Size of: ", stringify!(ishtar_thread_ctx_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_thread_ctx_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_thread_ctx_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_ctx_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_ctx_t),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locker) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_thread_ctx_t),
            "::",
            stringify!(locker)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_job_ctx_t {
    pub status: ishtar_job_status_e,
    pub job_id: *mut ::std::os::raw::c_void,
    pub locker: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_job_ctx_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_job_ctx_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_job_ctx_t>(),
        24usize,
        concat!("Size of: ", stringify!(ishtar_job_ctx_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_job_ctx_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_job_ctx_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_job_ctx_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).job_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_job_ctx_t),
            "::",
            stringify!(job_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locker) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_job_ctx_t),
            "::",
            stringify!(locker)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_job_t {
    pub ctx: *mut ishtar_job_ctx_t,
    pub worker_id: *mut ::std::os::raw::c_void,
    pub call_frame: *mut call_frame_t,
}
#[test]
fn bindgen_test_layout_ishtar_job_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_job_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_job_t>(),
        24usize,
        concat!("Size of: ", stringify!(ishtar_job_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_job_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_job_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_job_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).worker_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_job_t),
            "::",
            stringify!(worker_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call_frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_job_t),
            "::",
            stringify!(call_frame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_scheduler_t {
    pub task_index: u64,
    pub async_header: *mut ::std::os::raw::c_void,
    pub loop_: usize,
    pub _queue: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_scheduler_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_scheduler_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_scheduler_t>(),
        32usize,
        concat!("Size of: ", stringify!(ishtar_scheduler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_scheduler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_scheduler_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_scheduler_t),
            "::",
            stringify!(task_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_header) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_scheduler_t),
            "::",
            stringify!(async_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_scheduler_t),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._queue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_scheduler_t),
            "::",
            stringify!(_queue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeQualityTypeName {
    pub full_name: *mut ishtar_string_t,
    pub _fullname: *mut ishtar_string_t,
    pub _name: *mut ishtar_string_t,
    pub _namespace: *mut ishtar_string_t,
    pub _asm_name: *mut ishtar_string_t,
    pub _name_with_n_s: *mut ishtar_string_t,
}
#[test]
fn bindgen_test_layout_RuntimeQualityTypeName() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeQualityTypeName> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeQualityTypeName>(),
        48usize,
        concat!("Size of: ", stringify!(RuntimeQualityTypeName))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeQualityTypeName>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeQualityTypeName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeQualityTypeName),
            "::",
            stringify!(full_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fullname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeQualityTypeName),
            "::",
            stringify!(_fullname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeQualityTypeName),
            "::",
            stringify!(_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._namespace) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeQualityTypeName),
            "::",
            stringify!(_namespace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._asm_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeQualityTypeName),
            "::",
            stringify!(_asm_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name_with_n_s) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeQualityTypeName),
            "::",
            stringify!(_name_with_n_s)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtectedZone {
    pub start_addr: u32,
    pub end_addr: u32,
    pub try_end_label: i32,
    pub filter_addr: *mut ::std::os::raw::c_void,
    pub catch_addr: *mut ::std::os::raw::c_void,
    pub catch_class: *mut ::std::os::raw::c_void,
    pub types: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ProtectedZone() {
    const UNINIT: ::std::mem::MaybeUninit<ProtectedZone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ProtectedZone>(),
        48usize,
        concat!("Size of: ", stringify!(ProtectedZone))
    );
    assert_eq!(
        ::std::mem::align_of::<ProtectedZone>(),
        8usize,
        concat!("Alignment of ", stringify!(ProtectedZone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtectedZone),
            "::",
            stringify!(start_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtectedZone),
            "::",
            stringify!(end_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_end_label) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtectedZone),
            "::",
            stringify!(try_end_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtectedZone),
            "::",
            stringify!(filter_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).catch_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtectedZone),
            "::",
            stringify!(catch_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).catch_class) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtectedZone),
            "::",
            stringify!(catch_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtectedZone),
            "::",
            stringify!(types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeConstStorage {
    pub _module: *mut ishtar_module_t,
    pub storage: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RuntimeConstStorage() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeConstStorage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeConstStorage>(),
        16usize,
        concat!("Size of: ", stringify!(RuntimeConstStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeConstStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeConstStorage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeConstStorage),
            "::",
            stringify!(_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeConstStorage),
            "::",
            stringify!(storage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeFieldName {
    pub full_name: *mut ishtar_string_t,
    pub _full_name: *mut ishtar_string_t,
    pub _name: *mut ishtar_string_t,
    pub _class_name: *mut ishtar_string_t,
}
#[test]
fn bindgen_test_layout_RuntimeFieldName() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeFieldName> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeFieldName>(),
        32usize,
        concat!("Size of: ", stringify!(RuntimeFieldName))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeFieldName>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeFieldName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeFieldName),
            "::",
            stringify!(full_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._full_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeFieldName),
            "::",
            stringify!(_full_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeFieldName),
            "::",
            stringify!(_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._class_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeFieldName),
            "::",
            stringify!(_class_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_module_t {
    pub vault: *mut ::std::os::raw::c_void,
    pub i_d: u32,
    pub version: ishtar_version_t,
    pub alias_table: *mut ::std::os::raw::c_void,
    pub class_table: *mut ::std::os::raw::c_void,
    pub deps_table: *mut ::std::os::raw::c_void,
    pub aspects_table: *mut ::std::os::raw::c_void,
    pub types_table: *mut ::std::os::raw::c_void,
    pub generics_table: *mut ::std::os::raw::c_void,
    pub fields_table: *mut ::std::os::raw::c_void,
    pub string_table: *mut ::std::os::raw::c_void,
    pub const_storage: *mut ::std::os::raw::c_void,
    pub _name: *mut ishtar_string_t,
    pub _self: *mut ishtar_module_t,
    pub bootstrapper: *mut ishtar_class_t,
}
#[test]
fn bindgen_test_layout_ishtar_module_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_module_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_module_t>(),
        128usize,
        concat!("Size of: ", stringify!(ishtar_module_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_module_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_module_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vault) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(vault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(i_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias_table) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(alias_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_table) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(class_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deps_table) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(deps_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspects_table) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(aspects_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types_table) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(types_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generics_table) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(generics_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields_table) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(fields_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_table) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(string_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).const_storage) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(const_storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._self) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bootstrapper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_module_t),
            "::",
            stringify!(bootstrapper)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RuntimeAspectArgument {
    pub owner: *mut ishtar_aspect_t,
    pub index: u32,
    pub value: stackval,
    pub self_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RuntimeAspectArgument() {
    const UNINIT: ::std::mem::MaybeUninit<RuntimeAspectArgument> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RuntimeAspectArgument>(),
        48usize,
        concat!("Size of: ", stringify!(RuntimeAspectArgument))
    );
    assert_eq!(
        ::std::mem::align_of::<RuntimeAspectArgument>(),
        8usize,
        concat!("Alignment of ", stringify!(RuntimeAspectArgument))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeAspectArgument),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeAspectArgument),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeAspectArgument),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RuntimeAspectArgument),
            "::",
            stringify!(self_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_aspect_class_t {
    pub class_name: *mut ishtar_string_t,
}
#[test]
fn bindgen_test_layout_ishtar_aspect_class_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_aspect_class_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_aspect_class_t>(),
        8usize,
        concat!("Size of: ", stringify!(ishtar_aspect_class_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_aspect_class_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_aspect_class_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_class_t),
            "::",
            stringify!(class_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_aspect_method_t {
    pub class_name: *mut ishtar_string_t,
    pub method_name: *mut ishtar_string_t,
}
#[test]
fn bindgen_test_layout_ishtar_aspect_method_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_aspect_method_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_aspect_method_t>(),
        16usize,
        concat!("Size of: ", stringify!(ishtar_aspect_method_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_aspect_method_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_aspect_method_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_method_t),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_method_t),
            "::",
            stringify!(method_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_aspect_field_t {
    pub class_name: *mut ishtar_string_t,
    pub field_name: *mut ishtar_string_t,
}
#[test]
fn bindgen_test_layout_ishtar_aspect_field_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_aspect_field_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_aspect_field_t>(),
        16usize,
        concat!("Size of: ", stringify!(ishtar_aspect_field_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_aspect_field_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_aspect_field_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_field_t),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_field_t),
            "::",
            stringify!(field_name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ishtar_aspect_union_t {
    pub __bindgen_anon_1: ishtar_aspect_union_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ishtar_aspect_union_t__bindgen_ty_1 {
    pub class_aspect: ishtar_aspect_class_t,
    pub method_aspect: ishtar_aspect_method_t,
    pub field_aspect: ishtar_aspect_field_t,
}
#[test]
fn bindgen_test_layout_ishtar_aspect_union_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_aspect_union_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_aspect_union_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ishtar_aspect_union_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_aspect_union_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ishtar_aspect_union_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_aspect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_union_t__bindgen_ty_1),
            "::",
            stringify!(class_aspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_aspect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_union_t__bindgen_ty_1),
            "::",
            stringify!(method_aspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_aspect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_union_t__bindgen_ty_1),
            "::",
            stringify!(field_aspect)
        )
    );
}
#[test]
fn bindgen_test_layout_ishtar_aspect_union_t() {
    assert_eq!(
        ::std::mem::size_of::<ishtar_aspect_union_t>(),
        16usize,
        concat!("Size of: ", stringify!(ishtar_aspect_union_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_aspect_union_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_aspect_union_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ishtar_aspect_t {
    pub _self: *mut ishtar_aspect_t,
    pub _name: *mut ishtar_string_t,
    pub _union: ishtar_aspect_union_t,
    pub target: i32,
    pub arguments: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_aspect_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_aspect_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_aspect_t>(),
        48usize,
        concat!("Size of: ", stringify!(ishtar_aspect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_aspect_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_aspect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._self) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_t),
            "::",
            stringify!(_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_t),
            "::",
            stringify!(_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._union) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_t),
            "::",
            stringify!(_union)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arguments) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_aspect_t),
            "::",
            stringify!(arguments)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GcHeapUsageStat {
    pub pheap_size: i64,
    pub pfree_bytes: i64,
    pub punmapped_bytes: i64,
    pub pbytes_since_gc: i64,
    pub ptotal_bytes: i64,
}
#[test]
fn bindgen_test_layout_GcHeapUsageStat() {
    const UNINIT: ::std::mem::MaybeUninit<GcHeapUsageStat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GcHeapUsageStat>(),
        40usize,
        concat!("Size of: ", stringify!(GcHeapUsageStat))
    );
    assert_eq!(
        ::std::mem::align_of::<GcHeapUsageStat>(),
        8usize,
        concat!("Alignment of ", stringify!(GcHeapUsageStat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pheap_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GcHeapUsageStat),
            "::",
            stringify!(pheap_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfree_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GcHeapUsageStat),
            "::",
            stringify!(pfree_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).punmapped_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GcHeapUsageStat),
            "::",
            stringify!(punmapped_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbytes_since_gc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GcHeapUsageStat),
            "::",
            stringify!(pbytes_since_gc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptotal_bytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GcHeapUsageStat),
            "::",
            stringify!(ptotal_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GC_stack_base {
    pub mem_base: *mut ::std::os::raw::c_void,
    pub reg_base: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_GC_stack_base() {
    const UNINIT: ::std::mem::MaybeUninit<GC_stack_base> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GC_stack_base>(),
        16usize,
        concat!("Size of: ", stringify!(GC_stack_base))
    );
    assert_eq!(
        ::std::mem::align_of::<GC_stack_base>(),
        8usize,
        concat!("Alignment of ", stringify!(GC_stack_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_stack_base),
            "::",
            stringify!(mem_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GC_stack_base),
            "::",
            stringify!(reg_base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AllocatorBlock {
    pub parent: *mut ::std::os::raw::c_void,
    pub free: *mut ::std::os::raw::c_void,
    pub realloc: *mut ::std::os::raw::c_void,
    pub alloc_with_history: *mut ::std::os::raw::c_void,
    pub alloc_primitives_with_history: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AllocatorBlock() {
    const UNINIT: ::std::mem::MaybeUninit<AllocatorBlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AllocatorBlock>(),
        40usize,
        concat!("Size of: ", stringify!(AllocatorBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<AllocatorBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(AllocatorBlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocatorBlock),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocatorBlock),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocatorBlock),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_with_history) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocatorBlock),
            "::",
            stringify!(alloc_with_history)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alloc_primitives_with_history) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocatorBlock),
            "::",
            stringify!(alloc_primitives_with_history)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LongDoubleUnion {
    pub __bindgen_anon_1: LongDoubleUnion__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LongDoubleUnion__bindgen_ty_1 {
    pub long_value: i64,
    pub double_value: f64,
}
#[test]
fn bindgen_test_layout_LongDoubleUnion__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<LongDoubleUnion__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LongDoubleUnion__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(LongDoubleUnion__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<LongDoubleUnion__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(LongDoubleUnion__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LongDoubleUnion__bindgen_ty_1),
            "::",
            stringify!(long_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).double_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LongDoubleUnion__bindgen_ty_1),
            "::",
            stringify!(double_value)
        )
    );
}
#[test]
fn bindgen_test_layout_LongDoubleUnion() {
    assert_eq!(
        ::std::mem::size_of::<LongDoubleUnion>(),
        8usize,
        concat!("Size of: ", stringify!(LongDoubleUnion))
    );
    assert_eq!(
        ::std::mem::align_of::<LongDoubleUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(LongDoubleUnion))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cast_uint {
    pub __bindgen_anon_1: cast_uint__bindgen_ty_1,
    pub __bindgen_anon_2: cast_uint__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cast_uint__bindgen_ty_1 {
    pub _result: u64,
    pub _s1: u32,
}
#[test]
fn bindgen_test_layout_cast_uint__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cast_uint__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cast_uint__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cast_uint__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cast_uint__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cast_uint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cast_uint__bindgen_ty_1),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._s1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cast_uint__bindgen_ty_1),
            "::",
            stringify!(_s1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cast_uint__bindgen_ty_2 {
    pub _s2: u32,
}
#[test]
fn bindgen_test_layout_cast_uint__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<cast_uint__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cast_uint__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(cast_uint__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<cast_uint__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(cast_uint__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._s2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cast_uint__bindgen_ty_2),
            "::",
            stringify!(_s2)
        )
    );
}
#[test]
fn bindgen_test_layout_cast_uint() {
    assert_eq!(
        ::std::mem::size_of::<cast_uint>(),
        16usize,
        concat!("Size of: ", stringify!(cast_uint))
    );
    assert_eq!(
        ::std::mem::align_of::<cast_uint>(),
        8usize,
        concat!("Alignment of ", stringify!(cast_uint))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ishtar_task_data_t {
    pub semaphore: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ishtar_task_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<ishtar_task_data_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ishtar_task_data_t>(),
        8usize,
        concat!("Size of: ", stringify!(ishtar_task_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ishtar_task_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ishtar_task_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semaphore) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ishtar_task_data_t),
            "::",
            stringify!(semaphore)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WeakImmortalRef {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_WeakImmortalRef() {
    assert_eq!(
        ::std::mem::size_of::<WeakImmortalRef>(),
        4usize,
        concat!("Size of: ", stringify!(WeakImmortalRef))
    );
    assert_eq!(
        ::std::mem::align_of::<WeakImmortalRef>(),
        1usize,
        concat!("Alignment of ", stringify!(WeakImmortalRef))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ManagedMemHandle {
    pub size: usize,
    pub handler: *mut ::std::os::raw::c_void,
    pub original_addr: usize,
}
#[test]
fn bindgen_test_layout_ManagedMemHandle() {
    const UNINIT: ::std::mem::MaybeUninit<ManagedMemHandle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ManagedMemHandle>(),
        24usize,
        concat!("Size of: ", stringify!(ManagedMemHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<ManagedMemHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(ManagedMemHandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ManagedMemHandle),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ManagedMemHandle),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ManagedMemHandle),
            "::",
            stringify!(original_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapMemRef {
    pub heap_handle: usize,
    pub mem_ptr: usize,
    pub size: i64,
}
#[test]
fn bindgen_test_layout_HeapMemRef() {
    const UNINIT: ::std::mem::MaybeUninit<HeapMemRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HeapMemRef>(),
        24usize,
        concat!("Size of: ", stringify!(HeapMemRef))
    );
    assert_eq!(
        ::std::mem::align_of::<HeapMemRef>(),
        8usize,
        concat!("Alignment of ", stringify!(HeapMemRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heap_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapMemRef),
            "::",
            stringify!(heap_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapMemRef),
            "::",
            stringify!(mem_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapMemRef),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_sem_t {
    pub handle: usize,
}
#[test]
fn bindgen_test_layout_uv_sem_t() {
    const UNINIT: ::std::mem::MaybeUninit<uv_sem_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uv_sem_t>(),
        8usize,
        concat!("Size of: ", stringify!(uv_sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_sem_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_sem_t),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_thread_t {
    pub handle: usize,
}
#[test]
fn bindgen_test_layout_uv_thread_t() {
    const UNINIT: ::std::mem::MaybeUninit<uv_thread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uv_thread_t>(),
        8usize,
        concat!("Size of: ", stringify!(uv_thread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_thread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_thread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_thread_t),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_work_t {
    pub handle: usize,
}
#[test]
fn bindgen_test_layout_uv_work_t() {
    const UNINIT: ::std::mem::MaybeUninit<uv_work_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uv_work_t>(),
        8usize,
        concat!("Size of: ", stringify!(uv_work_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_work_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_work_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_work_t),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    pub fn vm_init();
}
extern "C" {
    pub fn execute_method(frame: *mut call_frame_t);
}
extern "C" {
    pub fn create_method(
        name: *mut ::std::os::raw::c_void,
        flags: method_flags_t,
        returnType: *mut ishtar_class_t,
        args: *mut ::std::os::raw::c_void,
    );
}
